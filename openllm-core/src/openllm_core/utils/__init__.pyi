import functools
from typing import Any, Dict, Tuple, TypeVar, Callable, Optional, Sequence, Literal, Union, Type
from bentoml._internal.models.model import ModelContext
from _bentoml_sdk.api import APIMethod
from openllm_core._typing_compat import overload, AnyCallable, ParamSpec, Concatenate
from bentoml._internal.types import PathType
from openllm_core.utils.import_utils import (
  ENV_VARS_TRUE_VALUES as ENV_VARS_TRUE_VALUES,
  is_autoawq_available as is_autoawq_available,
  is_autogptq_available as is_autogptq_available,
  is_bentoml_available as is_bentoml_available,
  is_bitsandbytes_available as is_bitsandbytes_available,
  is_triton_available as is_triton_available,
  is_grpc_available as is_grpc_available,
  is_jupyter_available as is_jupyter_available,
  is_jupytext_available as is_jupytext_available,
  is_notebook_available as is_notebook_available,
  is_peft_available as is_peft_available,
  is_flash_attn_2_available as is_flash_attn_2_available,
  is_torch_available as is_torch_available,
  is_transformers_available as is_transformers_available,
  is_vllm_available as is_vllm_available,
)
from openllm_core.utils import (
  analytics as analytics,
  codegen as codegen,
  dantic as dantic,
  lazy as lazy,
  pkg as pkg,
  representation as representation,
  serde as serde,
  import_utils as import_utils,
)
from openllm_core.utils.lazy import LazyLoader as LazyLoader, LazyModule as LazyModule, VersionInfo as VersionInfo
from openllm_core.utils.representation import ReprMixin as ReprMixin
from openllm_core.utils.serde import converter as converter
from pydantic import BaseModel

DEBUG: bool = ...
SHOW_CODEGEN: bool = ...
MYPY: bool = ...
DEBUG_ENV_VAR: str = ...
QUIET_ENV_VAR: str = ...
DEV_DEBUG_VAR: str = ...
WARNING_ENV_VAR: str = ...
OPENLLM_DEV_BUILD: str = ...

_T = TypeVar('_T')
R = TypeVar('R')
P = ParamSpec('P')

@functools.lru_cache(maxsize=1)
def has_gpus() -> bool: ...
def normalise_model_name(name: str) -> str: ...
def dict_filter_none(d: Dict[str, Any]) -> Dict[str, Any]: ...
def correct_closure(cls: Type[_T], ref: Type[R]) -> Type[_T]: ...
@overload
def api(func: Callable[Concatenate[Any, P], R]) -> APIMethod[P, R]: ...
@overload
def api(
  *,
  route: Optional[str] = ...,
  name: Optional[str] = ...,
  media_type: Optional[str] = ...,
  input: Optional[type[BaseModel]] = ...,
  output: Optional[type[BaseModel]] = ...,
  batchable: bool = ...,
  batch_dim: Union[int, Tuple[int, int]] = ...,
  max_batch_size: int = ...,
  max_latency_ms: int = ...,
) -> Callable[[Callable[Concatenate[Any, P], R]], APIMethod[P, R]]: ...
@overload
def api(
  func: Optional[Callable[Concatenate[Any, P], R]] = ...,
  *,
  name: Optional[str] = ...,
  route: Optional[str] = ...,
  media_type: Optional[str] = ...,
  input: Optional[type[BaseModel]] = ...,
  output: Optional[type[BaseModel]] = ...,
  batchable: bool = ...,
  batch_dim: Union[int, Tuple[int, int]] = ...,
  max_batch_size: int = ...,
  max_latency_ms: int = ...,
) -> Union[APIMethod[P, R], Callable[[Callable[Concatenate[Any, P], R]], APIMethod[P, R]]]: ...
def lenient_issubclass(cls: Type[Any], class_or_tuple: Optional[Union[Type[Any], Tuple[Type[Any], ...]]]) -> bool: ...
def resolve_user_filepath(filepath: str, ctx: Optional[str]) -> str: ...
def resolve_filepath(path: str, ctx: Optional[str] = ...) -> str: ...
def check_bool_env(env: str, default: bool = ...) -> bool: ...
def calc_dir_size(path: PathType) -> int: ...
def generate_hash_from_file(f: str, algorithm: Literal['md5', 'sha1'] = ...) -> str: ...
def getenv(
  env: str, default: Optional[Any] = ..., var: Optional[Sequence[str]] = ..., return_type: _T = ...
) -> _T: ...
def field_env_key(key: str, suffix: Optional[str] = ...) -> str: ...
def get_debug_mode() -> bool: ...
def get_quiet_mode() -> bool: ...
def get_disable_warnings() -> bool: ...
def set_disable_warnings(disable: bool = ...) -> None: ...
def set_debug_mode(enabled: bool, level: int = ...) -> None: ...
def set_quiet_mode(enabled: bool) -> None: ...
def gen_random_uuid(prefix: Optional[str] = ...) -> str: ...
def compose(*funcs: AnyCallable) -> AnyCallable: ...
def apply(transform: AnyCallable) -> Callable[[AnyCallable], AnyCallable]: ...
def validate_is_path(maybe_path: str) -> bool: ...
@overload
def first_not_none(*args: Optional[_T], default: _T) -> _T: ...
@overload
def first_not_none(*args: Optional[_T]) -> Optional[_T]: ...
@overload
def first_not_none(*args: Optional[_T], default: Optional[_T] = ...) -> Optional[_T]: ...
def generate_context(framework_name: str) -> ModelContext: ...
def in_notebook() -> bool: ...
def flatten_attrs(**attrs: Any) -> Tuple[Dict[str, Any], Dict[str, Any]]: ...
def configure_logging() -> None: ...

class Counter:
  counter: int
  def __next__(self) -> int: ...
  def reset(self) -> None: ...

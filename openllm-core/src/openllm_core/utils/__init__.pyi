from typing import Any, Dict, Tuple, TypeVar, Callable, Optional, Sequence, Literal, Union, Type
from bentoml._internal.models.model import ModelContext
from openllm_core._typing_compat import overload, AnyCallable
from bentoml._internal.types import PathType
from openllm_core.utils.import_utils import (
  ENV_VARS_TRUE_VALUES as ENV_VARS_TRUE_VALUES,
  OPTIONAL_DEPENDENCIES as OPTIONAL_DEPENDENCIES,
  is_autoawq_available as is_autoawq_available,
  is_autogptq_available as is_autogptq_available,
  is_bentoml_available as is_bentoml_available,
  is_bitsandbytes_available as is_bitsandbytes_available,
  is_triton_available as is_triton_available,
  is_ctranslate_available as is_ctranslate_available,
  is_grpc_available as is_grpc_available,
  is_jupyter_available as is_jupyter_available,
  is_jupytext_available as is_jupytext_available,
  is_notebook_available as is_notebook_available,
  is_peft_available as is_peft_available,
  is_flash_attn_2_available as is_flash_attn_2_available,
  is_torch_available as is_torch_available,
  is_transformers_available as is_transformers_available,
  is_vllm_available as is_vllm_available,
)
from openllm_core.utils import (
  analytics as analytics,
  codegen as codegen,
  dantic as dantic,
  lazy as lazy,
  pkg as pkg,
  representation as representation,
  serde as serde,
  import_utils as import_utils,
)
from openllm_core.utils.lazy import LazyLoader as LazyLoader, LazyModule as LazyModule, VersionInfo as VersionInfo
from openllm_core.utils.representation import ReprMixin as ReprMixin
from openllm_core.utils.serde import converter as converter

DEBUG: bool = ...
SHOW_CODEGEN: bool = ...
MYPY: bool = ...
DEBUG_ENV_VAR: str = ...
QUIET_ENV_VAR: str = ...
DEV_DEBUG_VAR: str = ...
WARNING_ENV_VAR: str = ...

_T = TypeVar('_T')

def lenient_issubclass(cls: Type[Any], class_or_tuple: Optional[Union[Type[Any], Tuple[Type[Any], ...]]]) -> bool: ...
def resolve_user_filepath(filepath: str, ctx: Optional[str]) -> str: ...
def resolve_filepath(path: str, ctx: Optional[str] = ...) -> str: ...
def check_bool_env(env: str, default: bool = ...) -> bool: ...
def calc_dir_size(path: PathType) -> int: ...
def generate_hash_from_file(f: str, algorithm: Literal['md5', 'sha1'] = ...) -> str: ...
def getenv(env: str, default: Optional[Any] = ..., var: Optional[Sequence[str]] = ...) -> Any: ...
def field_env_key(key: str, suffix: Optional[str] = ...) -> str: ...
def get_debug_mode() -> bool: ...
def get_quiet_mode() -> bool: ...
def get_disable_warnings() -> bool: ...
def set_disable_warnings(disable: bool = ...) -> None: ...
def set_debug_mode(enabled: bool, level: int = ...) -> None: ...
def set_quiet_mode(enabled: bool) -> None: ...
def gen_random_uuid(prefix: Optional[str] = ...) -> str: ...
def compose(*funcs: AnyCallable) -> AnyCallable: ...
def apply(transform: AnyCallable) -> Callable[[AnyCallable], AnyCallable]: ...
def validate_is_path(maybe_path: str) -> bool: ...
@overload
def first_not_none(*args: Optional[_T], default: _T) -> _T: ...
@overload
def first_not_none(*args: Optional[_T]) -> Optional[_T]: ...
@overload
def first_not_none(*args: Optional[_T], default: Optional[_T] = ...) -> Optional[_T]: ...
def generate_context(framework_name: str) -> ModelContext: ...
def in_notebook() -> bool: ...
def flatten_attrs(**attrs: Any) -> Tuple[Dict[str, Any], Dict[str, Any]]: ...
def configure_logging() -> None: ...
